<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>mato-framework: mato.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">mato-framework
   </div>
   <div id="projectbrief">Communication framework for modular control architecture</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">mato.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;glib.h&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for mato.h:</div>
<div class="dyncontent">
<div class="center"><img src="mato_8h__incl.png" border="0" usemap="#mato_8h" alt=""/></div>
<map name="mato_8h" id="mato_8h">
<area shape="rect" title=" " alt="" coords="5,5,73,32"/>
<area shape="rect" title=" " alt="" coords="10,80,69,107"/>
</map>
</div>
</div>
<p><a href="mato_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmodule__specification.html">module_specification</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Each module type has to provide the callbacks for its module instances.  <a href="structmodule__specification.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmodule__info.html">module_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of modules descriptions consists of structures describing the basic information about a module.  <a href="structmodule__info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a15a2c242b513b39cb717bf70978ce3fa"><td class="memItemLeft" align="right" valign="top"><a id="a15a2c242b513b39cb717bf70978ce3fa"></a>
typedef enum subscription_type_enum&#160;</td><td class="memItemRight" valign="bottom"><b>subscription_type</b></td></tr>
<tr class="separator:a15a2c242b513b39cb717bf70978ce3fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad20873465b8c85f182244c5a553f2837"><td class="memItemLeft" align="right" valign="top">typedef void *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mato_8h.html#ad20873465b8c85f182244c5a553f2837">create_instance_callback</a>) (int module_id)</td></tr>
<tr class="memdesc:ad20873465b8c85f182244c5a553f2837"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create instance data of a module and initialize it.  <a href="mato_8h.html#ad20873465b8c85f182244c5a553f2837">More...</a><br /></td></tr>
<tr class="separator:ad20873465b8c85f182244c5a553f2837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cdf8c706be95dbe5dc32dda2d0aacdf"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mato_8h.html#a5cdf8c706be95dbe5dc32dda2d0aacdf">start_instance_callback</a>) (void *instance_data)</td></tr>
<tr class="memdesc:a5cdf8c706be95dbe5dc32dda2d0aacdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the module instance.  <a href="mato_8h.html#a5cdf8c706be95dbe5dc32dda2d0aacdf">More...</a><br /></td></tr>
<tr class="separator:a5cdf8c706be95dbe5dc32dda2d0aacdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19ec8ae2c73a767ac23bcc3c861e8b53"><td class="memItemLeft" align="right" valign="top"><a id="a19ec8ae2c73a767ac23bcc3c861e8b53"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mato_8h.html#a19ec8ae2c73a767ac23bcc3c861e8b53">delete_instance_callback</a>) (void *instance_data)</td></tr>
<tr class="memdesc:a19ec8ae2c73a767ac23bcc3c861e8b53"><td class="mdescLeft">&#160;</td><td class="mdescRight">A request to delete the module instance has been made. This callback should deallocate the instance data. <br /></td></tr>
<tr class="separator:a19ec8ae2c73a767ac23bcc3c861e8b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a984f52f0434bb9e42814bf9c74f4791d"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mato_8h.html#a984f52f0434bb9e42814bf9c74f4791d">global_message_callback</a>) (void *instance_data, int module_id_sender, int message_id, int msg_length, void *message_data)</td></tr>
<tr class="memdesc:a984f52f0434bb9e42814bf9c74f4791d"><td class="mdescLeft">&#160;</td><td class="mdescRight">When some other module or the main program has sent a global message, this callback of each module is called immediatelly - from the thread of the sender.  <a href="mato_8h.html#a984f52f0434bb9e42814bf9c74f4791d">More...</a><br /></td></tr>
<tr class="separator:a984f52f0434bb9e42814bf9c74f4791d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9345221b935d9505595c583b54d31e86"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mato_8h.html#a9345221b935d9505595c583b54d31e86">subscriber_callback</a>) (void *instance_data, int sender_module_id, int data_length, void *new_data_ptr)</td></tr>
<tr class="memdesc:a9345221b935d9505595c583b54d31e86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modules that subscribe to the data on channels of other module instances provide this callback.  <a href="mato_8h.html#a9345221b935d9505595c583b54d31e86">More...</a><br /></td></tr>
<tr class="separator:a9345221b935d9505595c583b54d31e86"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a97f25ffc5cfdea7210d6d23eec033087"><td class="memItemLeft" align="right" valign="top"><a id="a97f25ffc5cfdea7210d6d23eec033087"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>subscription_type_enum</b> { <b>direct_data_ptr</b> = 1, 
<b>data_copy</b> = 2, 
<b>borrowed_pointer</b> = 3
 }</td></tr>
<tr class="separator:a97f25ffc5cfdea7210d6d23eec033087"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a96f8e9e3c32c9abdab14dabd590fae87"><td class="memItemLeft" align="right" valign="top"><a id="a96f8e9e3c32c9abdab14dabd590fae87"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mato_8h.html#a96f8e9e3c32c9abdab14dabd590fae87">mato_init</a> ()</td></tr>
<tr class="memdesc:a96f8e9e3c32c9abdab14dabd590fae87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the whole framework. Should be called first from the main program. <br /></td></tr>
<tr class="separator:a96f8e9e3c32c9abdab14dabd590fae87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43f0570e3ab59d7a021e93113437dcaf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mato_8h.html#a43f0570e3ab59d7a021e93113437dcaf">mato_register_new_type_of_module</a> (char *type, <a class="el" href="structmodule__specification.html">module_specification</a> *specification)</td></tr>
<tr class="memdesc:a43f0570e3ab59d7a021e93113437dcaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a new module type.  <a href="mato_8h.html#a43f0570e3ab59d7a021e93113437dcaf">More...</a><br /></td></tr>
<tr class="separator:a43f0570e3ab59d7a021e93113437dcaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a411a20bcfa908edbebe617fe5cc54667"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mato_8h.html#a411a20bcfa908edbebe617fe5cc54667">mato_create_new_module_instance</a> (const char *module_type, const char *module_name)</td></tr>
<tr class="memdesc:a411a20bcfa908edbebe617fe5cc54667"><td class="mdescLeft">&#160;</td><td class="mdescRight">The main program (or other module) can call this function to request creation of a module instance.  <a href="mato_8h.html#a411a20bcfa908edbebe617fe5cc54667">More...</a><br /></td></tr>
<tr class="separator:a411a20bcfa908edbebe617fe5cc54667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02ef7e731c9c9eaa342352a7e802c183"><td class="memItemLeft" align="right" valign="top"><a id="a02ef7e731c9c9eaa342352a7e802c183"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mato_8h.html#a02ef7e731c9c9eaa342352a7e802c183">mato_start</a> ()</td></tr>
<tr class="memdesc:a02ef7e731c9c9eaa342352a7e802c183"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the framework and all modules. This is typically called after all module instances have been created. <br /></td></tr>
<tr class="separator:a02ef7e731c9c9eaa342352a7e802c183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e94d7d4dc09ad58485227e60df20035"><td class="memItemLeft" align="right" valign="top"><a id="a6e94d7d4dc09ad58485227e60df20035"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mato_8h.html#a6e94d7d4dc09ad58485227e60df20035">mato_delete_module_instance</a> (int module_id)</td></tr>
<tr class="memdesc:a6e94d7d4dc09ad58485227e60df20035"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows to dynamically delete a module instance that was previously created. <br /></td></tr>
<tr class="separator:a6e94d7d4dc09ad58485227e60df20035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa753d75335e7a6ae0e00a6dcdbdb1412"><td class="memItemLeft" align="right" valign="top"><a id="aa753d75335e7a6ae0e00a6dcdbdb1412"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mato_8h.html#aa753d75335e7a6ae0e00a6dcdbdb1412">mato_get_module_id</a> (const char *module_name)</td></tr>
<tr class="memdesc:aa753d75335e7a6ae0e00a6dcdbdb1412"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate a module name of some existing module instance to its module id. Returns -1, if module name is not known. <br /></td></tr>
<tr class="separator:aa753d75335e7a6ae0e00a6dcdbdb1412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e839c2dcf0c134166ceca799e7987fd"><td class="memItemLeft" align="right" valign="top"><a id="a2e839c2dcf0c134166ceca799e7987fd"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mato_8h.html#a2e839c2dcf0c134166ceca799e7987fd">mato_get_module_name</a> (int module_id)</td></tr>
<tr class="memdesc:a2e839c2dcf0c134166ceca799e7987fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the name of a module with the specified module_id. <br /></td></tr>
<tr class="separator:a2e839c2dcf0c134166ceca799e7987fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28a6ba77196f8504bab5f3da059c5d5b"><td class="memItemLeft" align="right" valign="top"><a id="a28a6ba77196f8504bab5f3da059c5d5b"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mato_8h.html#a28a6ba77196f8504bab5f3da059c5d5b">mato_get_module_type</a> (int module_id)</td></tr>
<tr class="memdesc:a28a6ba77196f8504bab5f3da059c5d5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the type of a module with the specified module_id. <br /></td></tr>
<tr class="separator:a28a6ba77196f8504bab5f3da059c5d5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af07c3febed32408feb8a11c4d66c2251"><td class="memItemLeft" align="right" valign="top"><a id="af07c3febed32408feb8a11c4d66c2251"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mato_8h.html#af07c3febed32408feb8a11c4d66c2251">mato_subscribe</a> (int subscriber_module_id, int subscribed_module_id, int channel, <a class="el" href="mato_8h.html#a9345221b935d9505595c583b54d31e86">subscriber_callback</a> callback, int subscription_type)</td></tr>
<tr class="memdesc:af07c3febed32408feb8a11c4d66c2251"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe on a channel of some module instance. Returns a number that represents this subscription (a subscription_id). <br /></td></tr>
<tr class="separator:af07c3febed32408feb8a11c4d66c2251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14f9462b777a24c86af37b64d84142d0"><td class="memItemLeft" align="right" valign="top"><a id="a14f9462b777a24c86af37b64d84142d0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mato_8h.html#a14f9462b777a24c86af37b64d84142d0">mato_unsubscribe</a> (int module_id, int channel, int subscription_id)</td></tr>
<tr class="memdesc:a14f9462b777a24c86af37b64d84142d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a subscription_id, cancel the ongoing subscription to a channel of some module instance. <br /></td></tr>
<tr class="separator:a14f9462b777a24c86af37b64d84142d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c5249cc4fbb65587357c130ab618427"><td class="memItemLeft" align="right" valign="top"><a id="a7c5249cc4fbb65587357c130ab618427"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mato_8h.html#a7c5249cc4fbb65587357c130ab618427">mato_get_data_buffer</a> (int size)</td></tr>
<tr class="memdesc:a7c5249cc4fbb65587357c130ab618427"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a memory for a new message to be posted with post_data. <br /></td></tr>
<tr class="separator:a7c5249cc4fbb65587357c130ab618427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebd06bdcd1d952465c8c222c663d76fb"><td class="memItemLeft" align="right" valign="top"><a id="aebd06bdcd1d952465c8c222c663d76fb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mato_8h.html#aebd06bdcd1d952465c8c222c663d76fb">mato_post_data</a> (int id_of_posting_module, int channel, int data_length, void *data)</td></tr>
<tr class="memdesc:aebd06bdcd1d952465c8c222c663d76fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">A module instance posts a new message to its own output data channel by calling this function. <br /></td></tr>
<tr class="separator:aebd06bdcd1d952465c8c222c663d76fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae76f55dbca38f9a69095cda5f089a80b"><td class="memItemLeft" align="right" valign="top"><a id="ae76f55dbca38f9a69095cda5f089a80b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mato_8h.html#ae76f55dbca38f9a69095cda5f089a80b">mato_send_global_message</a> (int module_id_sender, int message_id, int msg_length, void *message_data)</td></tr>
<tr class="memdesc:ae76f55dbca38f9a69095cda5f089a80b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The main program or any module instance can post a global message to be posted to all modules immediatelly in the same thread by calling this function. <br /></td></tr>
<tr class="separator:ae76f55dbca38f9a69095cda5f089a80b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af356c7284b6f1d6be285de40d9e23b77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mato_8h.html#af356c7284b6f1d6be285de40d9e23b77">mato_get_data</a> (int id_module, int channel, int *data_length, void **data)</td></tr>
<tr class="memdesc:af356c7284b6f1d6be285de40d9e23b77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the most recently posted data of some channel of some module instance.  <a href="mato_8h.html#af356c7284b6f1d6be285de40d9e23b77">More...</a><br /></td></tr>
<tr class="separator:af356c7284b6f1d6be285de40d9e23b77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3c84af45ac99910057189ede367d72d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mato_8h.html#af3c84af45ac99910057189ede367d72d">mato_borrow_data</a> (int id_module, int channel, int *data_length, void **data)</td></tr>
<tr class="memdesc:af3c84af45ac99910057189ede367d72d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the most recently posted data of some channel of some module instance.  <a href="mato_8h.html#af3c84af45ac99910057189ede367d72d">More...</a><br /></td></tr>
<tr class="separator:af3c84af45ac99910057189ede367d72d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedcb803fd4a991e805e6c3813c829a35"><td class="memItemLeft" align="right" valign="top"><a id="aedcb803fd4a991e805e6c3813c829a35"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mato_8h.html#aedcb803fd4a991e805e6c3813c829a35">mato_release_data</a> (int id_module, int channel, void *data)</td></tr>
<tr class="memdesc:aedcb803fd4a991e805e6c3813c829a35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a borrowed pointer that was obtained either by <a class="el" href="mato_8h.html#af3c84af45ac99910057189ede367d72d" title="Retrieve the most recently posted data of some channel of some module instance.">mato_borrow_data()</a> or by a callback in the borrowed_pointer mode. <br /></td></tr>
<tr class="separator:aedcb803fd4a991e805e6c3813c829a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c6a3a9b7e7969e9d9324b1d937ff2a5"><td class="memItemLeft" align="right" valign="top">GArray *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mato_8h.html#a5c6a3a9b7e7969e9d9324b1d937ff2a5">mato_get_list_of_all_modules</a> ()</td></tr>
<tr class="memdesc:a5c6a3a9b7e7969e9d9324b1d937ff2a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the list of currently running modules.  <a href="mato_8h.html#a5c6a3a9b7e7969e9d9324b1d937ff2a5">More...</a><br /></td></tr>
<tr class="separator:a5c6a3a9b7e7969e9d9324b1d937ff2a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8c86d7dbb7acd09f1884c2e80ec698c"><td class="memItemLeft" align="right" valign="top">GArray *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mato_8h.html#ac8c86d7dbb7acd09f1884c2e80ec698c">mato_get_list_of_modules</a> (char *type)</td></tr>
<tr class="memdesc:ac8c86d7dbb7acd09f1884c2e80ec698c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the list of currently running modules of the specified type.  <a href="mato_8h.html#ac8c86d7dbb7acd09f1884c2e80ec698c">More...</a><br /></td></tr>
<tr class="separator:ac8c86d7dbb7acd09f1884c2e80ec698c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeafc9d85e29a73b9b5423cd661bd54c2"><td class="memItemLeft" align="right" valign="top"><a id="aeafc9d85e29a73b9b5423cd661bd54c2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mato_8h.html#aeafc9d85e29a73b9b5423cd661bd54c2">mato_free_list_of_modules</a> (GArray *a)</td></tr>
<tr class="memdesc:aeafc9d85e29a73b9b5423cd661bd54c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the list of modules returned by either of the two functions <a class="el" href="mato_8h.html#ac8c86d7dbb7acd09f1884c2e80ec698c" title="Retrieve the list of currently running modules of the specified type.">mato_get_list_of_modules()</a> or <a class="el" href="mato_8h.html#ac8c86d7dbb7acd09f1884c2e80ec698c" title="Retrieve the list of currently running modules of the specified type.">mato_get_list_of_modules()</a>. <br /></td></tr>
<tr class="separator:aeafc9d85e29a73b9b5423cd661bd54c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab49165685fd95d2e9f70f484e367c6f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mato_8h.html#ab49165685fd95d2e9f70f484e367c6f2">mato_data_buffer_usage</a> (int module_id, int channel, int *number_of_allocated_buffers, int *total_sum_of_ref_count)</td></tr>
<tr class="memdesc:ab49165685fd95d2e9f70f484e367c6f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a diagnostic information on use of the buffers by a particular channel of a particular module.  <a href="mato_8h.html#ab49165685fd95d2e9f70f484e367c6f2">More...</a><br /></td></tr>
<tr class="separator:ab49165685fd95d2e9f70f484e367c6f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b31044a7afec17426ec4d4e3354aa9f"><td class="memItemLeft" align="right" valign="top"><a id="a6b31044a7afec17426ec4d4e3354aa9f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mato_8h.html#a6b31044a7afec17426ec4d4e3354aa9f">mato_inc_thread_count</a> ()</td></tr>
<tr class="memdesc:a6b31044a7afec17426ec4d4e3354aa9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Each module instance (or other part of the program) that creates a new thread should call this funciton for each newly created thread. <br /></td></tr>
<tr class="separator:a6b31044a7afec17426ec4d4e3354aa9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a480acc181ff3a7d7c925d64e3d4a7442"><td class="memItemLeft" align="right" valign="top"><a id="a480acc181ff3a7d7c925d64e3d4a7442"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mato_8h.html#a480acc181ff3a7d7c925d64e3d4a7442">mato_dec_thread_count</a> ()</td></tr>
<tr class="memdesc:a480acc181ff3a7d7c925d64e3d4a7442"><td class="mdescLeft">&#160;</td><td class="mdescRight">Each thread that terminates should call this function just before it quits. <br /></td></tr>
<tr class="separator:a480acc181ff3a7d7c925d64e3d4a7442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a314629d6f743c699b26a534175986865"><td class="memItemLeft" align="right" valign="top"><a id="a314629d6f743c699b26a534175986865"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mato_8h.html#a314629d6f743c699b26a534175986865">mato_threads_running</a> ()</td></tr>
<tr class="memdesc:a314629d6f743c699b26a534175986865"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of threads currently running in the system. <br /></td></tr>
<tr class="separator:a314629d6f743c699b26a534175986865"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a0f80851fe27966d69a2a0dfbafdb7160"><td class="memItemLeft" align="right" valign="top">volatile int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mato_8h.html#a0f80851fe27966d69a2a0dfbafdb7160">program_runs</a></td></tr>
<tr class="memdesc:a0f80851fe27966d69a2a0dfbafdb7160"><td class="mdescLeft">&#160;</td><td class="mdescRight">This variable is set to non-zero when the program is about to terminate.  <a href="mato_8h.html#a0f80851fe27966d69a2a0dfbafdb7160">More...</a><br /></td></tr>
<tr class="separator:a0f80851fe27966d69a2a0dfbafdb7160"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Mato control framework - main header file. Declarations of the public interface of the framework. The framework manages the data flow between modules of the control architecture. Modules have types and names. There can be multiple instances of the same type of module, having different names. Module instances should only keep their local data inside of one structure that is created for each instance (we call it "instance data"). Each module type contains its "init()" function that registers the module in the framework so that it can be used by the main program and other modules. Each module type is specified by the structure <a class="el" href="structmodule__specification.html" title="Each module type has to provide the callbacks for its module instances.">module_specification</a> that lists the public interface of the module (used by the framework):</p><ul>
<li>create_instance_callback - creates a new instance of the module, i.e. allocates and initializes the module instance data, it is called by the framework when the main program or another module requests to create a new module instance</li>
<li>start_instance_callback - all modules are started by the framework by calling this function at once, typically after all instances have been created</li>
<li>delete_instance_callback - it is called by the framework when the main program or another module reqyests to delete the module instance</li>
<li>global_message_callback - global messages can be sent by anybody and they are immediatelly forwarded to the callback functions of all the modules Modules communicate by posting data in their output channels. Other modules can request the most recent data that have been posted by any module, or subscribe to receive all posted data immediatelly in their subscription callback function. The framework gives the possiblity to list all module types and all modules that are present in the system. Modules can be added and removed dynamically while the system runs. When sending a message, modules should ask the framework for the memory buffer that will be filled by the data of the message the module is sending. The framework deallocates the data buffers when they are not needed anymore automatically, unless the copy_mode is specified. </li>
</ul>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="ad20873465b8c85f182244c5a553f2837"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad20873465b8c85f182244c5a553f2837">&#9670;&nbsp;</a></span>create_instance_callback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void*(* create_instance_callback) (int module_id)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create instance data of a module and initialize it. </p>
<p>Each module should define this callback. This instance will be from now on always referred by the module_id passed in the argument. It is recommended that the module saves it to its instance_data. The function should return a pointer to the newly allocated instance data. </p>

</div>
</div>
<a id="a984f52f0434bb9e42814bf9c74f4791d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a984f52f0434bb9e42814bf9c74f4791d">&#9670;&nbsp;</a></span>global_message_callback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* global_message_callback) (void *instance_data, int module_id_sender, int message_id, int msg_length, void *message_data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>When some other module or the main program has sent a global message, this callback of each module is called immediatelly - from the thread of the sender. </p>
<p><br  />
 </p>

</div>
</div>
<a id="a5cdf8c706be95dbe5dc32dda2d0aacdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cdf8c706be95dbe5dc32dda2d0aacdf">&#9670;&nbsp;</a></span>start_instance_callback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* start_instance_callback) (void *instance_data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start the module instance. </p>
<p>Typically, a module instance will create a new thread that will take care of the functionality of the module (active module). Alternately, the module can remain passive - without a thread and only responding to the subscribes... This is also the right place for the module to subscribe to the data channels of other module instances, because they are expected to be instantiated at this point of time </p>

</div>
</div>
<a id="a9345221b935d9505595c583b54d31e86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9345221b935d9505595c583b54d31e86">&#9670;&nbsp;</a></span>subscriber_callback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* subscriber_callback) (void *instance_data, int sender_module_id, int data_length, void *new_data_ptr)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modules that subscribe to the data on channels of other module instances provide this callback. </p>
<p>It receives the instance data of the subscriber, the id of the sender module, and the actual raw data of the message and its length </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="af3c84af45ac99910057189ede367d72d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3c84af45ac99910057189ede367d72d">&#9670;&nbsp;</a></span>mato_borrow_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mato_borrow_data </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id_module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>data_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the most recently posted data of some channel of some module instance. </p>
<p>In this case, the data is not copied, but a pointer to read-only memory containing the data is provided. The module should return the borrowed pointer back to the framework by calling <a class="el" href="mato_8h.html#aedcb803fd4a991e805e6c3813c829a35" title="Return a borrowed pointer that was obtained either by mato_borrow_data() or by a callback in the borr...">mato_release_data()</a> when the data is not needed anymore. </p>

</div>
</div>
<a id="a411a20bcfa908edbebe617fe5cc54667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a411a20bcfa908edbebe617fe5cc54667">&#9670;&nbsp;</a></span>mato_create_new_module_instance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mato_create_new_module_instance </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>module_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>module_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The main program (or other module) can call this function to request creation of a module instance. </p>
<p>The function returns the new module id. </p>

</div>
</div>
<a id="ab49165685fd95d2e9f70f484e367c6f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab49165685fd95d2e9f70f484e367c6f2">&#9670;&nbsp;</a></span>mato_data_buffer_usage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mato_data_buffer_usage </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>module_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>number_of_allocated_buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>total_sum_of_ref_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provide a diagnostic information on use of the buffers by a particular channel of a particular module. </p>
<p>If this starts growing, the callbacks take too much time to process data and should be refactored. </p>

</div>
</div>
<a id="af356c7284b6f1d6be285de40d9e23b77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af356c7284b6f1d6be285de40d9e23b77">&#9670;&nbsp;</a></span>mato_get_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mato_get_data </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id_module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>data_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the most recently posted data of some channel of some module instance. </p>
<p>Data is copied into the buffer provided, and the length of the data is set to data_length. The calling module should release the memory by calling free() when it is not needed anymore. </p>

</div>
</div>
<a id="a5c6a3a9b7e7969e9d9324b1d937ff2a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c6a3a9b7e7969e9d9324b1d937ff2a5">&#9670;&nbsp;</a></span>mato_get_list_of_all_modules()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GArray* mato_get_list_of_all_modules </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the list of currently running modules. </p>
<p>The list should be freed by calling <a class="el" href="mato_8h.html#aeafc9d85e29a73b9b5423cd661bd54c2" title="Free the list of modules returned by either of the two functions mato_get_list_of_modules() or mato_g...">mato_free_list_of_modules()</a> when it is not needed anymore. </p>

</div>
</div>
<a id="ac8c86d7dbb7acd09f1884c2e80ec698c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8c86d7dbb7acd09f1884c2e80ec698c">&#9670;&nbsp;</a></span>mato_get_list_of_modules()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GArray* mato_get_list_of_modules </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the list of currently running modules of the specified type. </p>
<p>The list should be freed by calling <a class="el" href="mato_8h.html#aeafc9d85e29a73b9b5423cd661bd54c2" title="Free the list of modules returned by either of the two functions mato_get_list_of_modules() or mato_g...">mato_free_list_of_modules()</a> when it is not needed anymore. </p>

</div>
</div>
<a id="a43f0570e3ab59d7a021e93113437dcaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43f0570e3ab59d7a021e93113437dcaf">&#9670;&nbsp;</a></span>mato_register_new_type_of_module()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mato_register_new_type_of_module </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmodule__specification.html">module_specification</a> *&#160;</td>
          <td class="paramname"><em>specification</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a new module type. </p>
<p>This is typically called from the init() function of each module type, which should be called directly from the main program. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a0f80851fe27966d69a2a0dfbafdb7160"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f80851fe27966d69a2a0dfbafdb7160">&#9670;&nbsp;</a></span>program_runs</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile int program_runs</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This variable is set to non-zero when the program is about to terminate. </p>
<p>All threads should terminate at the earliest possbility </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
